<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>WebRTC on Enjoy301's tech blog</title><link>https://enjoy301.github.io/tags/webrtc/</link><description>Recent content in WebRTC on Enjoy301's tech blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 04 Jan 2023 22:35:00 +0900</lastBuildDate><atom:link href="https://enjoy301.github.io/tags/webrtc/index.xml" rel="self" type="application/rss+xml"/><item><title>WebRTC 개념 정리</title><link>https://enjoy301.github.io/p/webrtc-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC/</link><pubDate>Wed, 04 Jan 2023 22:35:00 +0900</pubDate><guid>https://enjoy301.github.io/p/webrtc-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC/</guid><description>&lt;p>스마일게이트 윈터데브캠프에서 WebRTC를 이용한 화상회의플랫폼을 제작하면서 필요한 WebRTC 개념을 정리합니다.&lt;/p>
&lt;h1 id="webrtc란">WebRTC란?&lt;/h1>
&lt;hr>
&lt;p>Web Real-Time Communication의 약자입니다.
웹 어플리케이션이 ==별도의 소프트웨어 없이== 데이터를 브라우저끼리 주고 받을 수 있는 기술입니다.
음성, 영상, 텍스트, 파일 등을 공유할 수 있습니다.&lt;/p>
&lt;h1 id="네트워크-용어">네트워크 용어&lt;/h1>
&lt;hr>
&lt;p>통신 과정 이해에 필요한 네트워크 용어를 먼저 알아봅시다.&lt;/p>
&lt;h2 id="nat">NAT&lt;/h2>
&lt;p>Netwrok Address Translation의 약자입니다.
라우터 등의 장비를 통해 다수의 private IP를 하나의 public IP로 변환하는 기술입니다.&lt;/p>
&lt;p>private IP 를 외부에서 알수 없기 때문에 보안성이 높다는 ==장점==이 있습니다.
private IP 를 외부에서 알수 없기 때문에 서버 입장에서 외부의 클라이언트에게 패킷을 전송할 방법이 없다는 ==단점==이 있습니다.
&lt;img src="https://enjoy301.github.io/image.png"
loading="lazy"
alt="image"
>&lt;/p>
&lt;h2 id="nat-travelsal">NAT travelsal&lt;/h2>
&lt;p>.&lt;/p>
&lt;h2 id="stun">STUN&lt;/h2>
&lt;p>Session Traversal Utilities for NAT의 약자입니다.
public에 위치하고, 요청을 보낸 클라이언트의 public IP address와 port를 알려주는 역할을 합니다.&lt;/p>
&lt;h2 id="turn">TURN&lt;/h2>
&lt;p>Traversal Using Relays around NAT의 약자입니다.
&lt;strong>네트워크 트래픽을 Relay 시켜주는 역할&lt;/strong>을 합니다.&lt;/p>
&lt;p>클라이언트는 서버에 Relay Allocation Request을 전송합니다.
TURN 서비스는 이 allocation에 대한 transport address를 예약하게 되는데, 바로 이 주소가 relay transport address가 됩니다.
이때, 클라이언트는 relay candidate를 획득하며, 사용 중인 시그널링 시스템을 사용하여 통신 상대에게 이를 전송합니다.
클라이언트들이 전송한 RTP 패킷을 relay합니다.&lt;/p>
&lt;p>TURN 서버와 관련된 리소스는 매우 비싸기 때문에 대부분은 &lt;strong>인증&lt;/strong>이 필요합니다.
TURN 서버에 트래픽이 몰리기 때문에 &lt;strong>마지막 수단&lt;/strong>으로 사용해야 합니다.&lt;/p>
&lt;h2 id="ice">ICE&lt;/h2>
&lt;p>Interactive Connectivity Establishment의 약자입니다.
ICE는 미디어와 데이터를 교환할 때 적합한 ICE candidate를 동적으로 찾아내는 프로세스입니다.
ICE candidate는 IP와 Port, 그리고 TCP/UDP 등의 프로토콜로 이뤄져 있는 transport address를 의미합니다.&lt;/p>
&lt;p>ICE candidate는 3가지로 나뉩니다.&lt;/p>
&lt;ul>
&lt;li>local address : 클라이언트의 private IP&lt;/li>
&lt;li>server reflexive address : NAT 장비가 매핑한 클라이언트의 public IP&lt;/li>
&lt;li>relayed address : TURN 서버가 패킷 릴레이를 위해 할당한 relay transport address&lt;/li>
&lt;/ul>
&lt;p>ICE는 ICE candidate를 수집하고, 각 candidate에 패킷을 송수신해서 각 경로에서 품질이 우수한 것을 사용합니다.&lt;/p>
&lt;h2 id="sdp">SDP&lt;/h2>
&lt;p>.&lt;/p>
&lt;h2 id="rtp">RTP&lt;/h2>
&lt;p>Real-time Transport Protocol의 약자입니다.
일반적으로 UDP로 동작합니다.
IP 멀티캐스트를 통해 여러 수신자에 데이터를 전송할 수 있게 합니다.&lt;/p>
&lt;h2 id="signaling">Signaling&lt;/h2>
&lt;p>.&lt;/p>
&lt;h1 id="peer-connection-process">Peer Connection Process&lt;/h1>
&lt;hr>
&lt;p>.&lt;/p>
&lt;h1 id="architecture">Architecture&lt;/h1>
&lt;hr>
&lt;p>연&lt;/p>
&lt;h2 id="mesh">Mesh&lt;/h2>
&lt;p>.&lt;/p>
&lt;h2 id="sfu">SFU&lt;/h2>
&lt;p>.&lt;/p>
&lt;h2 id="mcu">MCU&lt;/h2>
&lt;p>.&lt;/p>
&lt;h1 id="api">API&lt;/h1>
&lt;hr>
&lt;p>.&lt;/p>
&lt;h1 id="question">Question&lt;/h1>
&lt;hr>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">Q. 원래 이런거 필요없이도 서버에 요청 잘됐는데 WebRTC는 왜 STUN, TURN 같은 게 필요할까?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">A. client가 연결을 init할 때는 요청한 패킷에서 public IP를 알 수 있으니까 필요 없습니다.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">서버가 연결을 init할 때는 필요합니다. 서버는 클라이언트의 IP를 모르기 때문에 STUN, TURN을 이용하여 클라이언트의 public IP를 알아내는 과정이 필요합니다.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item></channel></rss>