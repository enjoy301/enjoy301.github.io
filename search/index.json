[{"content":"스마일게이트 윈터데브캠프에서 WebRTC를 이용한 화상회의플랫폼을 제작하면서 필요한 WebRTC 개념을 정리합니다.\nWebRTC란? Web Real-Time Communication의 약자입니다. 웹 어플리케이션이 ==별도의 소프트웨어 없이== 데이터를 브라우저끼리 주고 받을 수 있는 기술입니다. 음성, 영상, 텍스트, 파일 등을 공유할 수 있습니다.\n네트워크 용어 통신 과정 이해에 필요한 네트워크 용어를 먼저 알아봅시다.\nNAT Netwrok Address Translation의 약자입니다. 라우터 등의 장비를 통해 다수의 private IP를 하나의 public IP로 변환하는 기술입니다.\nprivate IP 를 외부에서 알수 없기 때문에 보안성이 높다는 ==장점==이 있습니다. private IP 를 외부에서 알수 없기 때문에 서버 입장에서 외부의 클라이언트에게 패킷을 전송할 방법이 없다는 ==단점==이 있습니다. NAT travelsal .\nSTUN Session Traversal Utilities for NAT의 약자입니다. public에 위치하고, 요청을 보낸 클라이언트의 public IP address와 port를 알려주는 역할을 합니다.\nTURN Traversal Using Relays around NAT의 약자입니다. 네트워크 트래픽을 Relay 시켜주는 역할을 합니다.\n클라이언트는 서버에 Relay Allocation Request을 전송합니다. TURN 서비스는 이 allocation에 대한 transport address를 예약하게 되는데, 바로 이 주소가 relay transport address가 됩니다. 이때, 클라이언트는 relay candidate를 획득하며, 사용 중인 시그널링 시스템을 사용하여 통신 상대에게 이를 전송합니다. 클라이언트들이 전송한 RTP 패킷을 relay합니다.\nTURN 서버와 관련된 리소스는 매우 비싸기 때문에 대부분은 인증이 필요합니다. TURN 서버에 트래픽이 몰리기 때문에 마지막 수단으로 사용해야 합니다.\nICE Interactive Connectivity Establishment의 약자입니다. ICE는 미디어와 데이터를 교환할 때 적합한 ICE candidate를 동적으로 찾아내는 프로세스입니다. ICE candidate는 IP와 Port, 그리고 TCP/UDP 등의 프로토콜로 이뤄져 있는 transport address를 의미합니다.\nICE candidate는 3가지로 나뉩니다.\nlocal address : 클라이언트의 private IP server reflexive address : NAT 장비가 매핑한 클라이언트의 public IP relayed address : TURN 서버가 패킷 릴레이를 위해 할당한 relay transport address ICE는 ICE candidate를 수집하고, 각 candidate에 패킷을 송수신해서 각 경로에서 품질이 우수한 것을 사용합니다.\nSDP .\nRTP Real-time Transport Protocol의 약자입니다. 일반적으로 UDP로 동작합니다. IP 멀티캐스트를 통해 여러 수신자에 데이터를 전송할 수 있게 합니다.\nSignaling .\nPeer Connection Process .\nArchitecture 연\nMesh .\nSFU .\nMCU .\nAPI .\nQuestion 1 2 3 4 Q. 원래 이런거 필요없이도 서버에 요청 잘됐는데 WebRTC는 왜 STUN, TURN 같은 게 필요할까? A. client가 연결을 init할 때는 요청한 패킷에서 public IP를 알 수 있으니까 필요 없습니다. 서버가 연결을 init할 때는 필요합니다. 서버는 클라이언트의 IP를 모르기 때문에 STUN, TURN을 이용하여 클라이언트의 public IP를 알아내는 과정이 필요합니다. ","date":"2023-01-04T22:35:00+09:00","permalink":"https://enjoy301.github.io/p/webrtc-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC/","title":"WebRTC 개념 정리"},{"content":"2022년의 전부였던 소마가 끝이 나고, 있었던 많은 일과 생각들을 정리해본다.\n1월 서류 접수 이때 나는 학교 앞 작은 회사에서 인턴을 하고 있었다. 소프트웨어 마에스트로가 뭔지 몰랐지만 100만원을 준다는 사실과 재미없는 학교를 잠시 떠날 수 있다는 사실, 그리고 서울에서 자취를 할 수 있다는 사실이 매력적이라 생각했다. 하지만 경쟁률이 너무 높아서 이번은 포트폴리오를 정리할 겸 지원해보고, 다음에 제대로 준비해서 지원해야겠다고 생각했다. 제출 당일 막바지에 어설픈 지원서를 제출했다.\n다시보면 너무 어설픈 지원서였다. 첫 번째로, 자기소개의 첫 문장이 \u0026ldquo;귀찮음을 코딩으로 해결하는 개발자입니다.\u0026rdquo; 였다. 이 문장을 보면 귀찮음이라는 단어가 눈에 띄여 부정적인 인상을 준다. 좋은 말만 적어도 모지란 자기소개서인데, 제일 큰 글자, 제일 첫 번째 단어로 \u0026ldquo;귀찮음\u0026quot;이 보이니 읽기 싫게 많드는 효과가 있다..\n두 번째로, 자기소개서에 장래희망 부분에 \u0026ldquo;젊을 때 돈 많이 벌어서 오션뷰 아파트에서 뒹굴뒹굴 살고 싶습니다.\u0026rdquo; 라고 적었다. 내가 인사 담당자라면 이런 말을 적은 사람을 뽑지 않을 것이다. 근데 오히려 심층 면접 때 이 항목 덕에 차가웠던 면접장에서 다른 사람의 웃음을 터뜨렸다.\n마지막으로, 2000자내외로 써야했던 항목들을 500자 내외로 적었다. 너무 귀찮았고 글 솜씨도 없었기 때문에. 다시 생각해보니 오히려 일관성이 있는 것 같기도 하네. 여튼 나처럼 지원서 쓰지 마시오.\n그래도 유일하게 잘한 점은 결국 제출했다는 것이다.\n엄청난 수의 경쟁률, 하위 99.3%의 글 솜씨, 쓸 게 없는 포트폴리오였지만 결국 제출했고, 그것이 나의 2022년을 바꿨다.\n겁 먹지 말고 도전하자. 떨어지면 어때. 0%와 1%는 단 1%의 차이지만, 1%는 돌림판을 돌려볼 기회는 얻을 수 있으니까.\n이 생각이 소마 과정을 통틀어 얻은 깨달음 중 넘버원이고, 나의 실패한 소마 전체 과정을 꿰뚫는 깨달음이다.\n3월 코딩 테스트와 면접 코딩 테스트 솔직히 코테는 너무 쉬웠다. 제한 시간이 100초라서 시간복잡도 100억으로 설계해도 통과할 수 있다. 알고리즘보다 중요한건 SQL, CSS, JS문제 인 것 같다. 알고리즘은 단시간에 확 잘해지기 힘든데, SQL, CSS, JS는 그냥 한번 보고 가기만해도 맞출 수 있는 문제였기 때문이다. 백준 기준 실버1 이하의 문제들이니 너무 걱정말길.\n코테는 그냥 허수를 거르기 위함이 아니였을까? 점수도 안알려주고, 면접에서도 일절 언급하지 않았다.\n그리고.. 연습 겸 도전했던 소마에 2차 코테까지 합격했다. 마지막 심층 면접만 앞뒀는데, 면접을 볼 지 말지 고민이 되었다. 서울을 혼자 가는 게 처음이였고, 비행기 값이 비쌌고, 내가 부산에서 제일 말 못하는 사람이기 때문이다.\n면접 무식하면 용감하다. 그래서 용감하게 도전했다. 면접이 진행되는 코엑스 건물이 너무 넓어 길을 잃을 뻔했다.\n면접은 5대5로 진행되었다. 넓은 회의실과 면접관과의 먼 거리, 면접관들의 차가운 분위기 때문에 취조받는 느낌이 들었다.\n면접은 제출한 포트폴리오 기반으로 엄청 자세하게 물어본다. 난 포트폴리오에 수화 인식하는 머신러닝 프로젝트를 썼는데, 질문이 꼬리에 꼬리를 물며 나왔다.\n머신러닝, 딥러닝, AI의 정의들을 물어봤고, 데이터는 어떻게 모았는 지, 어떻게 동작하는 지, 어떤 문제가 있었는 지, 어떻게 해결했는 지 등등.\n이 부분은 나에게 긍정적으로 작용했던 게, 그 프로젝트에 상당한 애착이 있었고, 내 대학교 생활 2년의 거의 전부였기 때문이다. 그래서 이야기하듯이 면접을 진행했던 것 같다. 비하인드 스토리를 얘기하며 다 웃고, 어떻게 더 발전시킬지 여쭤보기도 하며 면접장을 내 것으로 만들었다.\n다른 면접자들을 보며 느낀건 너무 떨려서 그런지 말을 잘 못하는지, 면접관의 질문에 맞지 않는 답을 하는 사람이 너무 많았다.\n그리고 최종합격했다. 합격하자마자 든 생각은 \u0026lsquo;이게 되네?\u0026lsquo;였다. 약간 소마를 의심하기도 했다. 나를 합격시켜준다고? 보는 눈 되게 없네.\n5월 예비 과정 이때 내 자존감은 바닥을 쳤다. 대부분 나보다 3~4년 나이가 많았고, 너무 좋은 대학이였다. 난 부산에서 내가 제일 코딩 잘하는 줄 알았는데, 난 그냥 말하는 감자였다.\n","date":"2022-12-18T20:08:00+09:00","permalink":"https://enjoy301.github.io/p/%EC%86%8C%EB%A7%88-13%EA%B8%B0-%ED%9A%8C%EA%B3%A0/","title":"소마 13기 회고"},{"content":"문제 링크 https://www.acmicpc.net/problem/1987\n문제 풀이 지나왔던 알파벳을 기록해야되는데, BFS를 이용하면 구현하기 까다롭다. 그래서 DFS를 이용한다.\n가로, 세로 최대 20 X 20으로 400칸을 탐색하면 DFS만으로는 시간초과가 난다. 그래서 백트래킹을 이용해야 한다.\nrecursive 함수의 인자로 지나왔던 알파벳을 기록하는 배열을 넘겨주려 했는데, 비효율적으로 메모리가 많이 필요하기 때문에, 전역변수로 선언해준다 (visited 배열).\nLine 25~27이 이번 알고리즘의 핵심이다. 25번째 줄에서 백트래킹을 위해 지나왔던 알파벳을 기록해주고, 26번째 줄에서 재귀함수를 호출한다.\n재귀함수가 끝나면, 27번째 줄에서 지나왔던 알파벳을 기록해준 것을 취소한다.\n알고리즘 순서 26개의 알파벳을 기록할 배열을 만든다. (0, 0)부터 DFS 함수를 시작한다. 입력받은 배열의 범위를 벗어나지 않은 상하좌우를 검색한다. 이미 지나왔던 알파벳이라면 더이상 탐색하지 않는다. 지나왔던 알파벳이 아니라면, 알파벳을 기록하고, DFS 함수를 호출한다. DFS 함수가 끝나면, 지나왔던 알파벳을 기록한 것을 취소한다. 소스 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;array\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; int max_count = 1, R, C; array\u0026lt;array\u0026lt;char, 20\u0026gt;, 20\u0026gt; arr; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; adders = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}}; bool visited[26]; void recursive(int depth, int x, int y){ if(max_count \u0026lt; depth){ max_count = depth; } for(pair\u0026lt;int, int\u0026gt; p : adders){ int new_x = x+p.first; int new_y = y+p.second; if(new_x \u0026gt;= 0 \u0026amp;\u0026amp; new_x \u0026lt; R \u0026amp;\u0026amp; new_y \u0026gt;= 0 \u0026amp;\u0026amp; new_y \u0026lt; C){ // 백트래킹 if(!visited[arr[new_x][new_y] - \u0026#39;A\u0026#39;]){ visited[arr[new_x][new_y] - \u0026#39;A\u0026#39;] = true; recursive(depth+1, new_x, new_y); visited[arr[new_x][new_y] - \u0026#39;A\u0026#39;] = false; } } } } int main(void){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin \u0026gt;\u0026gt; R \u0026gt;\u0026gt; C; for(int i=0; i\u0026lt;R; i++){ for(int j=0; j\u0026lt;C; j++){ cin \u0026gt;\u0026gt; arr[i][j]; } } visited[arr[0][0] - \u0026#39;A\u0026#39;] = true; recursive(1, 0, 0); cout \u0026lt;\u0026lt; max_count \u0026lt;\u0026lt; endl; return 0; } 엣지 케이스 1 2 3 4 5 6 7 8 9 10 11 10 10 ABCDEFGHIJ KLMNOPQRST UVWXYZABCD EFGHIJKLMN OPQRSTUVWX YZABCDEFGH IJKLMNOPQR STUVWXYZAB CDEFGHIJKL MOPQRSTUVW 26이 출력되어야 한다.\n","date":"2022-09-14T13:04:00+09:00","permalink":"https://enjoy301.github.io/p/c-%EB%B0%B1%EC%A4%80-1987%EB%B2%88-%EC%95%8C%ED%8C%8C%EB%B2%B3/","title":"[C++] 백준 1987번 - 알파벳"}]